// .JA. in order to use Firestore you have to import both.
// otherwise you will receive an error calling firebase.firestore()
import * as firebase from "firebase";
import "firebase/firestore";
import DocumentReference = firebase.firestore.DocumentReference;
import { deepCopyObject } from "tsutil";
import { Logger } from "log4js";
import { Observable } from "rxjs/Observable";
import { LoggingService } from "logging-service-node";
import { Config } from "./types";
import { isNil } from "lodash";
import WriteBatch = firebase.firestore.WriteBatch;

export class FirebaseService {
  private log: Logger;
  private initialized = false;
  private database: firebase.firestore.Firestore;
  private FID = "_id";    // firebase auto-generated id

  constructor() {
    LoggingService.initializeLoggingService();
    this.log = LoggingService.getLogger(FirebaseService.name);
  }

  /**
   * Initialize the firebase service.
   * @param {Config} config confu
   */
  initializeFirebaseApp(config: Config) {

    this.log.info("Initializing Firebase / Firestore...");
    const app = firebase.initializeApp(config);

    // Initialize Cloud Firestore through Firebase
    this.database = firebase.firestore();

    this.initialized = true;
    this.log.info("Firebase / Firestore initialized.");
  }

  /**
   * Check if the firebase service was initialized or not.
   *
   * @returns {boolean}
   */
  isInitialized() {
    return this.initialized;
  }

  /**
   * Get the firebase database.
   * @returns {firebase.firestore.Firestore}
   */
  getDatabase() {
    return this.database;
  }

  /**
   * Add a new object to the collection and set automatically the returned id generated by Firebase.
   *
   * <p/>Documentation: https://firebase.google.com/docs/firestore/manage-data/add-data
   *
   * @param {string} collection name.
   * @param classInstance class instance to be added in the collection.
   * @returns {Promise<DocumentReference>} Promise.
   */
  add(collection: string, classInstance: any): Promise<DocumentReference> {
    // {...object} ==> only converts the own single attributes and not an array of other Objects
    const object = deepCopyObject(classInstance);

    // validate
    if (object.hasOwnProperty(this.FID) && !isNil(object[this.FID])) {
      const errmsg = "The auto-generated id field called '" + this.FID
        + "' has a value: " + object[this.FID] + ". If you are trying to update the record, call the set() method. "
        + "Otherwise set the auto-generated id to null before calling add().";
      this.log.error(errmsg);
      throw new Error(errmsg);
    }

    object.createdAt = firebase.firestore.FieldValue.serverTimestamp();
    const log = this.log;

    return this.database
      .collection(collection)
      .add(object)
      .then((response) => {
        log.debug("ADD: object id {}", response.id);
        // set the firebase auto-generated id
        classInstance[this.FID] = response.id;
        return response;
      });
  }

  /**
   * Update a document of the collection. If the document does not exist an error will be thrown.
   *
   * <p/>You can specify if the data, including new properties, should be merged into the existing document
   * setting the parameter mergeData to true. This is the default behavior.
   * Otherwise, its content will be overwritten with the newly provided data.
   *
   * <p/>Documentation: https://firebase.google.com/docs/firestore/manage-data/add-data
   *
   * @param {string} collection name.
   * @param classInstance class instance to be updated in the collection-
   * @param mergeData If true (default value), it does not overwrite the whole record,
   *        it only merges the new/modified fields.
   * @returns {Promise<void>} Promise.
   */
  update(collection: string, classInstance: any, mergeData: boolean = true): Promise<void> {
    // {...object} ==> only converts the own single attributes and not an array of other Objects
    const object = deepCopyObject(classInstance);
    const log = this.log;

    this.validateBeforeUpdate(object);

    const docId = object[this.FID];
    object.modifiedAt = firebase.firestore.FieldValue.serverTimestamp();
    const setOptions = {merge: mergeData};
    // remove the firebase id before saving
    this.removeId(object);

    // .JA. FireStore: set() will update and overwrite the whole document with the fields,
    // unless you use the option {merge: true},
    return this.database
      .collection(collection)
      .doc(docId)
      .set(object, setOptions).then(() => {
        log.debug("UPDATE: object id {}", docId);
      });
  }

  private validateBeforeUpdate(object: any): boolean {
    // validate
    if (!object.hasOwnProperty(this.FID) || isNil(object[this.FID])) {
      const errmsg = "The auto-generated id field is missing. "
        + "If you are trying to add a new record, call the add() method. "
        + "Otherwise set an existing value for the auto-generated id field called '" + this.FID + "'"
        + "before calling set().";
      this.log.error(errmsg);
      throw new Error(errmsg);
    }
    return true;
  }

  /**
   * Batch processing for new or existing objects. The method checks for an existing auto-generated ID and execute an
   * update, otherwise it executes an insert into the collection.
   *
   * <p/>It can only insert/update up to 500 records at time. Therefore it returns a list of Promises which corresponds
   * to each batch transaction executed.
   *
   * <p>An error will be thrown if the list of objects is empty or any pre-requisite is not fulfilled.
   *
   * @param {string} collection name.
   * @param {any[]} objects to be added / updated in the collection.
   * @param mergeData If true (default value), it does not overwrite the whole record,
   *        it only merges the new/modified fields.
   * @param {boolean} stopOnError Informs if the batch processing should exit the loop of document processing
   *        (default value, i.e., stopOnError = true) or if it should continue to try to save the next document
   *        (stopOnError = false).
   * @returns {Promise<DocumentReference>[]} list of Promises.
   */
  batch(collection: string, objects: any[], mergeData: boolean = true, stopOnError: boolean = true): Promise<void>[] {
    const log = this.log;

    // validation
    let errmsg: string = null;
    if ( isNil(objects) || isNil(collection) || collection === "") {
      errmsg = "The parameters 'collection' and 'objects' are mandatory.";
    } else if ( objects.constructor !== Array ) {
      errmsg = "The parameter 'objects' is not an array.";
    } else if (objects.length == 0) {
      errmsg = "The parameter 'objects' is empty. No elements to save using batch operations.";
    }

    if (errmsg) {
      log.error(errmsg);
      throw new Error(errmsg);
    }

    const maxIndex = 499;  // 0 to 499  = 500 elements
    const stopException = {};
    const promises: Promise<void>[] = [];

    try {
      let batch: WriteBatch = null;
      let startBatch = true;
      for (let i = 0; i < objects.length; i++) {

        if (startBatch) {
          // Get a new write batch
          batch = this.database.batch();
          startBatch = false;
        }

        const obj = objects[i];
        try {
          this.addOrUpdateToBatch(batch, collection, obj, mergeData);
          // time to commit the batch process ?
          // for each time, the index reaches 500 elements
          if (i > 0 && i % maxIndex == 0) {
            startBatch = true;
            // commit and
            // add the new promise to the list
            promises.push(batch.commit());
          }
        } catch (error) {
          log.error("An error occurred while saving the object: {}. Error:\n{}", JSON.stringify(obj), error);
          if (stopOnError) {
            throw stopException;
          }
        }
      }

      // the startBatch works also as a flag and informs if the commit was called or not
      // before exiting the for-loop
      if (!startBatch) {
        // commit and
        // add the new promise to the list
        promises.push(batch.commit());
      }
    } catch (error) {
      if (error !== stopException) throw error;
      // do nothing
    }

    return promises;
  }

  private addOrUpdateToBatch(batch: WriteBatch,
                             collection: string, classInstance: any, mergeData: boolean = true): void {
    // {...object} ==> only converts the own single attributes and not an array of other Objects
    const object = deepCopyObject(classInstance);

    let reference: DocumentReference = null;
    if (!object.hasOwnProperty(this.FID) || isNil(object[this.FID])) {
      // Create a ref with auto-generated ID
      reference = this.database.collection(collection).doc();
      object.createdAt = firebase.firestore.FieldValue.serverTimestamp();
      batch.set(reference, object);
    } else if (this.validateBeforeUpdate(object)) {
      // get the existing reference
      reference = this.database.collection(collection).doc(object[this.FID]);
      object.modifiedAt = firebase.firestore.FieldValue.serverTimestamp();
      const setOptions = {merge: mergeData};
      // remove the firebase id before saving
      this.removeId(object);
      batch.set(reference, object);
    }
  }

  /**
   * Add or update a document of the collection.
   *
   * <p/>You can specify if the data, including new properties, should be merged into the existing document
   * setting the parameter mergeData to true. This is the default behavior.
   * Otherwise, its content will be overwritten with the newly provided data.
   *
   * <p/>Documentation: https://firebase.google.com/docs/firestore/manage-data/add-data
   *
   * @param {string} collection name.
   * @param classInstance class instance to be updated in the collection-
   * @param mergeData If true (default value), it does not overwrite the whole record,
   *        it only merges the new/modified fields.
   * @returns {Promise<DocumentReference>} Promise.
   */
  addOrUpdate(collection: string, classInstance: any, mergeData: boolean = true): Promise<void> {
    // {...object} ==> only converts the own single attributes and not an array of other Objects
    const object = deepCopyObject(classInstance);

    let reference: DocumentReference = null;
    if (!object.hasOwnProperty(this.FID) || isNil(object[this.FID])) {
      // Create a ref with auto-generated ID
      reference = this.database.collection(collection).doc();
      object.createdAt = firebase.firestore.FieldValue.serverTimestamp();
      return reference.set(reference, object);
    } else if (this.validateBeforeUpdate(object)) {
      // get the existing reference
      reference = this.database.collection(collection).doc(object[this.FID]);
      object.modifiedAt = firebase.firestore.FieldValue.serverTimestamp();
      const setOptions = {merge: mergeData};
      // remove the firebase id before saving
      this.removeId(object);
      return reference.set(reference, object);
    }
  }

  /**
   * Get all the objects of a collection.
   *
   * @param {string} collection name.
   * @returns {Promise<any>} Promise that returns an array of objects
   */
  get(collection: string): Observable<Array<any>> {
    // transform class variables into local variables
    const db = this.database;
    const log = this.log;
    const fid = this.FID;

    return Observable.create(function(observer: any) {
    const objects: any = [];
     db.collection(collection)
      .get()
      .then(
        (querySnapshot) => {
          querySnapshot.forEach((doc) => {
            log.info("" + doc);
            const objWithId = {
              ... doc.data(),
              fid: doc.id
            };
            objects.push(objWithId);
          });
          // return the result array
          observer.next(objects);
        }).catch(
       // Log the rejection reason
       (error) => {
         log.error(error);
         observer.error("Error while getting collection", error);
       });
    });
  }

  /**
   * Set a value for the firebase auto-generated id.
   * @param object object ot add/change the firebase auto-generated id.
   * @param {string} id value for the firebase auto-generated id.
   */
  setId(object: any, id: string) {
    object[this.FID] = id;
  }

  /**
   * Remove the firebase auto-generated id from the object.
   * @param object object to remove the id.
   * @returns {any} the object without
   */
  removeId(object: any): any {
    delete object[this.FID];
  }

}
