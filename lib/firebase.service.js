"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// .JA. in order to use Firestore you have to import both.
// otherwise you will receive an error calling firebase.firestore()
const firebase = __importStar(require("firebase"));
require("firebase/firestore");
const tsutil_1 = require("tsutil");
const logging_service_node_1 = require("logging-service-node");
const lodash_1 = require("lodash");
const rxjs_1 = require("rxjs");
class FirebaseService {
    constructor() {
        this.initialized = false;
        this.FID = "_id"; // firebase auto-generated id
        logging_service_node_1.LoggingService.initializeLoggingService();
        this.log = logging_service_node_1.LoggingService.getLogger(FirebaseService.name);
    }
    /**
     * Initialize the firebase service.
     * @param {Config} config confu
     */
    initializeFirebaseApp(config) {
        this.log.info("Initializing Firebase / Firestore...");
        const app = firebase.initializeApp(config);
        // Initialize Cloud Firestore through Firebase
        this.database = firebase.firestore();
        this.initialized = true;
        this.log.info("Firebase / Firestore initialized.");
    }
    /**
     * Check if the firebase service was initialized or not.
     *
     * @returns {boolean}
     */
    isInitialized() {
        return this.initialized;
    }
    /**
     * Get the firebase database.
     * @returns {firebase.firestore.Firestore}
     */
    getDatabase() {
        return this.database;
    }
    /**
     * Add a new object to the collection and set automatically the returned id generated by Firebase.
     *
     * <p/>Documentation: https://firebase.google.com/docs/firestore/manage-data/add-data
     *
     * @param {string} collection name.
     * @param classInstance class instance to be added in the collection.
     * @returns {Promise<DocumentReference>} Promise.
     */
    add(collection, classInstance) {
        // {...object} ==> only converts the own single attributes and not an array of other Objects
        const object = tsutil_1.deepCopyObject(classInstance);
        // validate
        if (object.hasOwnProperty(this.FID) && !lodash_1.isNil(object[this.FID])) {
            const errmsg = "The auto-generated id field called '" + this.FID
                + "' has a value: " + object[this.FID] + ". If you are trying to update the record, call the set() method. "
                + "Otherwise set the auto-generated id to null before calling add().";
            this.log.error(errmsg);
            throw new Error(errmsg);
        }
        object.createdAt = firebase.firestore.FieldValue.serverTimestamp();
        const log = this.log;
        return this.database
            .collection(collection)
            .add(object)
            .then((response) => {
            log.debug("ADD: object id {}", response.id);
            // set the firebase auto-generated id
            classInstance[this.FID] = response.id;
            return response;
        });
    }
    /**
     * Update a document of the collection. If the document does not exist an error will be thrown.
     *
     * <p/>You can specify if the data, including new properties, should be merged into the existing document
     * setting the parameter mergeData to true. This is the default behavior.
     * Otherwise, its content will be overwritten with the newly provided data.
     *
     * <p/>Documentation: https://firebase.google.com/docs/firestore/manage-data/add-data
     *
     * @param {string} collection name.
     * @param classInstance class instance to be updated in the collection-
     * @param mergeData If true (default value), it does not overwrite the whole record,
     *        it only merges the new/modified fields.
     * @returns {Promise<void>} Promise.
     */
    update(collection, classInstance, mergeData = true) {
        // {...object} ==> only converts the own single attributes and not an array of other Objects
        const object = tsutil_1.deepCopyObject(classInstance);
        const log = this.log;
        this.validateBeforeUpdate(object);
        const docId = object[this.FID];
        object.modifiedAt = firebase.firestore.FieldValue.serverTimestamp();
        const setOptions = { merge: mergeData };
        // remove the firebase id before saving
        this.removeId(object);
        // .JA. FireStore: set() will update and overwrite the whole document with the fields,
        // unless you use the option {merge: true},
        return this.database
            .collection(collection)
            .doc(docId)
            .set(object, setOptions).then(() => {
            log.debug("UPDATE: object id {}", docId);
        });
    }
    validateBeforeUpdate(object) {
        // validate
        if (!object.hasOwnProperty(this.FID) || lodash_1.isNil(object[this.FID])) {
            const errmsg = "The auto-generated id field is missing. "
                + "If you are trying to add a new record, call the add() method. "
                + "Otherwise set an existing value for the auto-generated id field called '" + this.FID + "'"
                + "before calling set().";
            this.log.error(errmsg);
            throw new Error(errmsg);
        }
        return true;
    }
    /**
     * Batch processing for new or existing objects. The method checks for an existing auto-generated ID and execute an
     * update, otherwise it executes an insert into the collection.
     *
     * <p/>It can only insert/update up to 500 records at time. Therefore it returns a list of Promises which corresponds
     * to each batch transaction executed.
     *
     * <p>An error will be thrown if the list of objects is empty or any pre-requisite is not fulfilled.
     *
     * @param {string} collection name.
     * @param {any[]} objects to be added / updated in the collection.
     * @param mergeData If true (default value), it does not overwrite the whole record,
     *        it only merges the new/modified fields.
     * @param {boolean} stopOnError Informs if the batch processing should exit the loop of document processing
     *        (default value, i.e., stopOnError = true) or if it should continue to try to save the next document
     *        (stopOnError = false).
     * @returns {Promise<DocumentReference>[]} list of Promises.
     */
    batch(collection, objects, mergeData = true, stopOnError = true) {
        const log = this.log;
        // validation
        let errmsg = null;
        if (lodash_1.isNil(objects) || lodash_1.isNil(collection) || collection === "") {
            errmsg = "The parameters 'collection' and 'objects' are mandatory.";
        }
        else if (objects.constructor !== Array) {
            errmsg = "The parameter 'objects' is not an array.";
        }
        else if (objects.length == 0) {
            errmsg = "The parameter 'objects' is empty. No elements to save using batch operations.";
        }
        if (errmsg) {
            log.error(errmsg);
            throw new Error(errmsg);
        }
        const maxIndex = 499; // 0 to 499  = 500 elements
        const stopException = {};
        const promises = [];
        try {
            let batch = null;
            let startBatch = true;
            for (let i = 0; i < objects.length; i++) {
                if (startBatch) {
                    // Get a new write batch
                    batch = this.database.batch();
                    startBatch = false;
                }
                const obj = objects[i];
                try {
                    this.addOrUpdateToBatch(batch, collection, obj, mergeData);
                    // time to commit the batch process ?
                    // for each time, the index reaches 500 elements
                    if (i > 0 && i % maxIndex == 0) {
                        startBatch = true;
                        // commit and
                        // add the new promise to the list
                        promises.push(batch.commit());
                    }
                }
                catch (error) {
                    log.error("An error occurred while saving the object: {}. Error:\n{}", JSON.stringify(obj), error);
                    if (stopOnError) {
                        throw stopException;
                    }
                }
            }
            // the startBatch works also as a flag and informs if the commit was called or not
            // before exiting the for-loop
            if (!startBatch) {
                // commit and
                // add the new promise to the list
                promises.push(batch.commit());
            }
        }
        catch (error) {
            if (error !== stopException)
                throw error;
            // do nothing
        }
        return promises;
    }
    addOrUpdateToBatch(batch, collection, classInstance, mergeData = true) {
        // {...object} ==> only converts the own single attributes and not an array of other Objects
        const object = tsutil_1.deepCopyObject(classInstance);
        let reference = null;
        if (!object.hasOwnProperty(this.FID) || lodash_1.isNil(object[this.FID])) {
            // Create a ref with auto-generated ID
            reference = this.database.collection(collection).doc();
            object.createdAt = firebase.firestore.FieldValue.serverTimestamp();
            batch.set(reference, object);
        }
        else if (this.validateBeforeUpdate(object)) {
            // get the existing reference
            reference = this.database.collection(collection).doc(object[this.FID]);
            object.modifiedAt = firebase.firestore.FieldValue.serverTimestamp();
            const setOptions = { merge: mergeData };
            // remove the firebase id before saving
            this.removeId(object);
            batch.set(reference, object);
        }
    }
    /**
     * Add or update a document of the collection.
     *
     * <p/>You can specify if the data, including new properties, should be merged into the existing document
     * setting the parameter mergeData to true. This is the default behavior.
     * Otherwise, its content will be overwritten with the newly provided data.
     *
     * <p/>Documentation: https://firebase.google.com/docs/firestore/manage-data/add-data
     *
     * @param {string} collection name.
     * @param classInstance class instance to be updated in the collection-
     * @param mergeData If true (default value), it does not overwrite the whole record,
     *        it only merges the new/modified fields.
     * @returns {Promise<DocumentReference>} Promise.
     */
    addOrUpdate(collection, classInstance, mergeData = true) {
        // {...object} ==> only converts the own single attributes and not an array of other Objects
        const object = tsutil_1.deepCopyObject(classInstance);
        let reference = null;
        if (!object.hasOwnProperty(this.FID) || lodash_1.isNil(object[this.FID])) {
            // Create a ref with auto-generated ID
            reference = this.database.collection(collection).doc();
            object.createdAt = firebase.firestore.FieldValue.serverTimestamp();
            return reference.set(reference, object);
        }
        else if (this.validateBeforeUpdate(object)) {
            // get the existing reference
            reference = this.database.collection(collection).doc(object[this.FID]);
            object.modifiedAt = firebase.firestore.FieldValue.serverTimestamp();
            const setOptions = { merge: mergeData };
            // remove the firebase id before saving
            this.removeId(object);
            return reference.set(reference, object);
        }
    }
    /**
     * Get all the objects of a collection.
     *
     * @param {string} collection name.
     * @returns {Promise<any>} Promise that returns an array of objects
     */
    get(collection) {
        // transform class variables into local variables
        const db = this.database;
        const log = this.log;
        const fid = this.FID;
        return new rxjs_1.Observable(function (observer) {
            const objects = [];
            db.collection(collection)
                .get()
                .then((querySnapshot) => {
                querySnapshot.forEach((doc) => {
                    log.info("" + doc);
                    const objWithId = Object.assign({}, doc.data(), { fid: doc.id });
                    objects.push(objWithId);
                });
                // return the result array
                observer.next(objects);
            }).catch(
            // Log the rejection reason
            (error) => {
                log.error(error);
                observer.error("Error while getting collection", error);
            });
        });
    }
    /**
     * Set a value for the firebase auto-generated id.
     * @param object object ot add/change the firebase auto-generated id.
     * @param {string} id value for the firebase auto-generated id.
     */
    setId(object, id) {
        object[this.FID] = id;
    }
    /**
     * Remove the firebase auto-generated id from the object.
     * @param object object to remove the id.
     * @returns {any} the object without
     */
    removeId(object) {
        delete object[this.FID];
    }
}
exports.FirebaseService = FirebaseService;
//# sourceMappingURL=firebase.service.js.map